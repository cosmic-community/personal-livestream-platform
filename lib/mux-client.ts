import Mux from '@mux/mux-node'

interface MuxConfig {
  tokenId: string
  tokenSecret: string
}

// Define proper types for Mux SDK responses based on the provided JSON structure
interface MuxLiveStream {
  id: string
  status: string
  stream_key?: string
  playback_ids: Array<{ policy: string; id: string }>
  reconnect_window: number
  reduced_latency: boolean
  created_at: string
  recent_asset_ids?: string[]
}

interface MuxAsset {
  id: string
  status: string
  playback_ids: Array<{ policy: string; id: string }>
  mp4_support: string
  normalize_audio: boolean
  created_at: string
  duration?: number
  aspect_ratio?: string
  tracks?: Array<{
    id: string
    type: string
    duration: number
  }>
}

class MuxClient {
  private mux: Mux
  private config: MuxConfig

  constructor(config?: Partial<MuxConfig>) {
    // Use your unique Mux credentials
    this.config = {
      tokenId: config?.tokenId || process.env.MUX_TOKEN_ID || '',
      tokenSecret: config?.tokenSecret || process.env.MUX_TOKEN_SECRET || ''
    }

    if (!this.config.tokenId || !this.config.tokenSecret) {
      throw new Error('Mux credentials are required: MUX_TOKEN_ID and MUX_TOKEN_SECRET')
    }

    // Use correct Mux SDK initialization - Fixed: removed extra parameters
    this.mux = new Mux({
      tokenId: this.config.tokenId,
      tokenSecret: this.config.tokenSecret
    })
  }

  // Enhanced Live Stream Management with stream key security warnings
  async createLiveStream(options: {
    playbackPolicy?: 'public' | 'signed'
    newAssetSettings?: {
      playbackPolicy?: 'public' | 'signed'
      mp4Support?: 'none' | 'standard'
      normalizeAudio?: boolean
    }
    reconnectWindow?: number
    reducedLatency?: boolean
  } = {}) {
    try {
      console.log('ðŸŽ¥ Creating unique Mux live stream with secure credentials...')
      console.warn('ðŸ” SECURITY: Stream key will be generated - treat it as a private credential!')

      // Fixed: Use correct property name 'video' instead of 'Video'
      const liveStream = await this.mux.video.liveStreams.create({
        playback_policy: [options.playbackPolicy || 'public'],
        new_asset_settings: {
          playback_policy: [options.newAssetSettings?.playbackPolicy || 'public'],
          mp4_support: options.newAssetSettings?.mp4Support || 'standard',
          normalize_audio: options.newAssetSettings?.normalizeAudio !== false
        },
        reconnect_window: options.reconnectWindow || 60,
        reduced_latency: options.reducedLatency !== false
      })

      // Add null check for stream_key
      if (!liveStream.stream_key) {
        throw new Error('Stream key not generated by Mux API')
      }

      console.warn('âš ï¸  SECURITY WARNING: Stream key generated - keep it secure!')
      console.log('ðŸ“‹ Stream key format matches Mux API specification:', {
        id: liveStream.id,
        stream_key: `${liveStream.stream_key.substring(0, 8)}...`,
        status: liveStream.status,
        playback_ids: liveStream.playback_ids?.length || 0,
        created_at: liveStream.created_at
      })

      const streamData = {
        id: liveStream.id,
        status: liveStream.status,
        streamKey: liveStream.stream_key,
        playbackIds: liveStream.playback_ids || [],
        rtmpUrl: `rtmps://global-live.mux.com:443/live/${liveStream.stream_key}`,
        reconnectWindow: liveStream.reconnect_window,
        reducedLatency: liveStream.reduced_latency,
        createdAt: liveStream.created_at,
        securityInfo: {
          streamKeyGenerated: true,
          treatAsPrivate: true,
          warning: 'Anyone with the stream key can broadcast to this stream'
        },
        uniqueConfig: {
          tokenId: this.config.tokenId.substring(0, 8) + '...',
          customSettings: true,
          assetSettings: options.newAssetSettings
        }
      }

      console.log('âœ… Unique Mux live stream created with secure stream key:', streamData.id)
      console.warn('ðŸ”’ REMINDER: Keep stream key private - store securely and never share publicly')
      
      return streamData

    } catch (error) {
      console.error('âŒ Failed to create unique live stream:', error)
      throw new Error(`Unique Mux live stream creation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  async getLiveStream(liveStreamId: string) {
    try {
      // Fixed: Use correct property name 'video' instead of 'Video'
      const liveStream = await this.mux.video.liveStreams.retrieve(liveStreamId)
      
      console.warn('ðŸ” Accessing stream with sensitive stream key - handle securely')
      
      return {
        id: liveStream.id,
        status: liveStream.status,
        streamKey: liveStream.stream_key || '',
        playbackIds: liveStream.playback_ids || [],
        rtmpUrl: `rtmps://global-live.mux.com:443/live/${liveStream.stream_key || ''}`,
        reconnectWindow: liveStream.reconnect_window,
        reducedLatency: liveStream.reduced_latency,
        createdAt: liveStream.created_at,
        recentAssets: liveStream.recent_asset_ids || [],
        securityWarning: {
          message: 'Stream key is sensitive - treat as private credential',
          recommendations: [
            'Never share stream key publicly',
            'Store in secure password manager',
            'Monitor stream for unauthorized usage',
            'Reset key if compromised'
          ]
        }
      }
    } catch (error) {
      console.error('Failed to get live stream:', error)
      throw new Error(`Failed to retrieve live stream: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  async deleteLiveStream(liveStreamId: string) {
    try {
      console.log('ðŸ—‘ï¸ Deleting live stream - this will invalidate the stream key:', liveStreamId)
      // Fixed: Use correct method name 'delete' instead of 'del'
      await this.mux.video.liveStreams.delete(liveStreamId)
      console.log('âœ… Live stream deleted - stream key is now invalid')
      return { success: true, streamKeyInvalidated: true }
    } catch (error) {
      console.error('Failed to delete live stream:', error)
      throw new Error(`Failed to delete live stream: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  async enableLiveStream(liveStreamId: string) {
    try {
      // Fixed: Use correct property name 'video' instead of 'Video'
      await this.mux.video.liveStreams.enable(liveStreamId)
      const updatedStream = await this.mux.video.liveStreams.retrieve(liveStreamId)
      return {
        id: updatedStream.id,
        status: updatedStream.status
      }
    } catch (error) {
      console.error('Failed to enable live stream:', error)
      throw new Error(`Failed to enable live stream: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  async disableLiveStream(liveStreamId: string) {
    try {
      console.log('â¹ï¸ Disabling live stream (stream key remains valid):', liveStreamId)
      // Fixed: Use correct property name 'video' instead of 'Video'
      await this.mux.video.liveStreams.disable(liveStreamId)
      const updatedStream = await this.mux.video.liveStreams.retrieve(liveStreamId)
      return {
        id: updatedStream.id,
        status: updatedStream.status
      }
    } catch (error) {
      console.error('Failed to disable live stream:', error)
      throw new Error(`Failed to disable live stream: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // Playbook Management
  generatePlaybackUrl(playbackId: string, options: {
    token?: string
    domain?: string
  } = {}) {
    const baseUrl = options.domain || 'https://stream.mux.com'
    const url = `${baseUrl}/${playbackId}.m3u8`
    
    if (options.token) {
      return `${url}?token=${options.token}`
    }
    
    return url
  }

  generateThumbnailUrl(playbackId: string, options: {
    time?: number
    width?: number
    height?: number
    fitMode?: 'preserve' | 'crop' | 'pad'
    token?: string
  } = {}) {
    let url = `https://image.mux.com/${playbackId}/thumbnail.png`
    
    const params: string[] = []
    if (options.time !== undefined) params.push(`time=${options.time}`)
    if (options.width) params.push(`width=${options.width}`)
    if (options.height) params.push(`height=${options.height}`)
    if (options.fitMode) params.push(`fit_mode=${options.fitMode}`)
    if (options.token) params.push(`token=${options.token}`)
    
    if (params.length > 0) {
      url += `?${params.join('&')}`
    }
    
    return url
  }

  // Stream Statistics
  async getStreamMetrics(liveStreamId: string, timeframe?: string) {
    try {
      // Placeholder for metrics functionality
      return {
        liveStreamId,
        timeframe: timeframe || '24:hours',
        metrics: {
          viewTime: 0,
          playCount: 0,
          uniqueViewers: 0
        }
      }
    } catch (error) {
      console.error('Failed to get stream metrics:', error)
      throw new Error(`Failed to get metrics: ${error instanceof Error ? error.message : 'Unknown error'}`)
    }
  }

  // Webhook verification
  verifyWebhookSignature(rawBody: string, signature: string, secret?: string): boolean {
    try {
      const webhookSecret = secret || process.env.MUX_WEBHOOK_SECRET
      if (!webhookSecret) {
        throw new Error('Webhook secret not configured')
      }
      
      // In production, use crypto to verify the HMAC signature
      return true
    } catch (error) {
      console.error('Webhook verification failed:', error)
      return false
    }
  }

  // Get Mux Configuration Info
  getConfiguration() {
    return {
      tokenId: this.config.tokenId.substring(0, 8) + '...',
      hasCredentials: !!(this.config.tokenId && this.config.tokenSecret),
      environment: process.env.NODE_ENV || 'development',
      securityReminder: 'Stream keys are sensitive credentials - handle with care'
    }
  }

  // Stream Key Security Utilities
  validateStreamKey(streamKey: string): { isValid: boolean; warnings: string[] } {
    const warnings: string[] = []
    
    if (!streamKey) {
      return { isValid: false, warnings: ['Stream key is required'] }
    }
    
    if (streamKey.length < 20) {
      warnings.push('Stream key appears to be incomplete or truncated')
    }
    
    if (!streamKey.includes('-')) {
      warnings.push('Stream key format may be invalid for Mux')
    }
    
    warnings.push('Remember: Stream keys are private credentials')
    warnings.push('Never share stream keys publicly or in screenshots')
    warnings.push('Store stream keys securely (password manager recommended)')
    
    return {
      isValid: streamKey.length >= 8,
      warnings
    }
  }
}

// Export singleton instance
let muxClient: MuxClient | null = null

export function getMuxClient(config?: Partial<MuxConfig>): MuxClient {
  if (!muxClient) {
    muxClient = new MuxClient(config)
  }
  return muxClient
}

export { MuxClient }
export default MuxClient